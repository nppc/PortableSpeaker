
AVRASM ver. 2.2.7  C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm Fri May 03 21:01:29 2019

[builtin](2): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\tn85def.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(21): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\tn85def.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(93): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\PWM.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(94): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\ADC.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(95): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\MovAverage.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(96): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\math.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(97): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\scheduler.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(98): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\ws2812b.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(100): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.inc'
[builtin](2): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\tn85def.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(21): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\tn85def.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(93): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\PWM.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(94): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\ADC.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(95): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\MovAverage.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(96): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\math.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(97): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\scheduler.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(98): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\ws2812b.inc'
C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.asm(100): Including file 'C:\src\Tennp\Git\PortableSpeaker\Firmware\Charger\main.inc'
                                 
                                 ; LiIon Charger firmware
                                 
                                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny85.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn85def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny85
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny85
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN85DEF_INC_
                                 #define _TN85DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny85
                                 #pragma AVRPART ADMIN PART_NAME ATtiny85
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x93
                                 .equ	SIGNATURE_002	= 0x0b
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2
                                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	GIMSK	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	TCCR0B	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	TCCR1	= 0x30
                                 .equ	TCNT1	= 0x2f
                                 .equ	OCR1A	= 0x2e
                                 .equ	OCR1C	= 0x2d
                                 .equ	GTCCR	= 0x2c
                                 .equ	OCR1B	= 0x2b
                                 .equ	TCCR0A	= 0x2a
                                 .equ	OCR0A	= 0x29
                                 .equ	OCR0B	= 0x28
                                 .equ	PLLCSR	= 0x27
                                 .equ	CLKPR	= 0x26
                                 .equ	DT1A	= 0x25
                                 .equ	DT1B	= 0x24
                                 .equ	DTPS	= 0x23
                                 .equ	DWDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	PRR	= 0x20
                                 .equ	EEARH	= 0x1f
                                 .equ	EEARL	= 0x1e
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PCMSK	= 0x15
                                 .equ	DIDR0	= 0x14
                                 .equ	GPIOR2	= 0x13
                                 .equ	GPIOR1	= 0x12
                                 .equ	GPIOR0	= 0x11
                                 .equ	USIBR	= 0x10
                                 .equ	USIDR	= 0x0f
                                 .equ	USISR	= 0x0e
                                 .equ	USICR	= 0x0d
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	ADCSRB	= 0x03
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Data Register, Port B
                                 .equ	PORTB0	= 0	; 
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; 
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; 
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; 
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; 
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; 
                                 .equ	PB5	= 5	; For compatibility
                                 
                                 ; DDRB - Data Direction Register, Port B
                                 .equ	DDB0	= 0	; 
                                 .equ	DDB1	= 1	; 
                                 .equ	DDB2	= 2	; 
                                 .equ	DDB3	= 3	; 
                                 .equ	DDB4	= 4	; 
                                 .equ	DDB5	= 5	; 
                                 
                                 ; PINB - Input Pins, Port B
                                 .equ	PINB0	= 0	; 
                                 .equ	PINB1	= 1	; 
                                 .equ	PINB2	= 2	; 
                                 .equ	PINB3	= 3	; 
                                 .equ	PINB4	= 4	; 
                                 .equ	PINB5	= 5	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR0 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	REFS2	= 4	; Reference Selection Bit 2
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                                 .equ	IPR	= 5	; Input Polarity Mode
                                 .equ	BIN	= 7	; Bipolar Input Mode
                                 
                                 ; DIDR0 - Digital Input Disable Register 0
                                 .equ	ADC1D	= 2	; ADC1 Digital input Disable
                                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                                 .equ	ADC2D	= 4	; ADC2 Digital input Disable
                                 .equ	ADC0D	= 5	; ADC0 Digital input Disable
                                 
                                 
                                 ; ***** USI **************************
                                 ; USIBR - USI Buffer Register
                                 .equ	USIBR0	= 0	; USI Buffer Register bit 0
                                 .equ	USIBR1	= 1	; USI Buffer Register bit 1
                                 .equ	USIBR2	= 2	; USI Buffer Register bit 2
                                 .equ	USIBR3	= 3	; USI Buffer Register bit 3
                                 .equ	USIBR4	= 4	; USI Buffer Register bit 4
                                 .equ	USIBR5	= 5	; USI Buffer Register bit 5
                                 .equ	USIBR6	= 6	; USI Buffer Register bit 6
                                 .equ	USIBR7	= 7	; USI Buffer Register bit 7
                                 
                                 ; USIDR - USI Data Register
                                 .equ	USIDR0	= 0	; USI Data Register bit 0
                                 .equ	USIDR1	= 1	; USI Data Register bit 1
                                 .equ	USIDR2	= 2	; USI Data Register bit 2
                                 .equ	USIDR3	= 3	; USI Data Register bit 3
                                 .equ	USIDR4	= 4	; USI Data Register bit 4
                                 .equ	USIDR5	= 5	; USI Data Register bit 5
                                 .equ	USIDR6	= 6	; USI Data Register bit 6
                                 .equ	USIDR7	= 7	; USI Data Register bit 7
                                 
                                 ; USISR - USI Status Register
                                 .equ	USICNT0	= 0	; USI Counter Value Bit 0
                                 .equ	USICNT1	= 1	; USI Counter Value Bit 1
                                 .equ	USICNT2	= 2	; USI Counter Value Bit 2
                                 .equ	USICNT3	= 3	; USI Counter Value Bit 3
                                 .equ	USIDC	= 4	; Data Output Collision
                                 .equ	USIPF	= 5	; Stop Condition Flag
                                 .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                                 .equ	USISIF	= 7	; Start Condition Interrupt Flag
                                 
                                 ; USICR - USI Control Register
                                 .equ	USITC	= 0	; Toggle Clock Port Pin
                                 .equ	USICLK	= 1	; Clock Strobe
                                 .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                                 .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                                 .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                                 .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                                 .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                                 .equ	USISIE	= 7	; Start Condition Interrupt Enable
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 
                                 ; GIMSK - General Interrupt Mask Register
                                 .equ	GICR	= GIMSK	; For compatibility
                                 .equ	PCIE	= 5	; Pin Change Interrupt Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 
                                 ; GIFR - General Interrupt Flag register
                                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 
                                 ; PCMSK - Pin Change Enable Mask
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEARH - EEPROM Address Register High Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 .equ	OCIE0A	= 4	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                                 .equ	OCF0A	= 4	; Timer/Counter0 Output Compare Flag 0A
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 ;.equ	OCR0_0	= 0	; 
                                 ;.equ	OCR0_1	= 1	; 
                                 ;.equ	OCR0_2	= 2	; 
                                 ;.equ	OCR0_3	= 3	; 
                                 ;.equ	OCR0_4	= 4	; 
                                 ;.equ	OCR0_5	= 5	; 
                                 ;.equ	OCR0_6	= 6	; 
                                 ;.equ	OCR0_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSR0	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TCCR1 - Timer/Counter Control Register
                                 .equ	CS10	= 0	; Clock Select Bits
                                 .equ	CS11	= 1	; Clock Select Bits
                                 .equ	CS12	= 2	; Clock Select Bits
                                 .equ	CS13	= 3	; Clock Select Bits
                                 .equ	COM1A0	= 4	; Compare Output Mode, Bit 1
                                 .equ	COM1A1	= 5	; Compare Output Mode, Bit 0
                                 .equ	PWM1A	= 6	; Pulse Width Modulator Enable
                                 .equ	CTC1	= 7	; Clear Timer/Counter on Compare Match
                                 
                                 ; TCNT1 - Timer/Counter Register
                                 .equ	TCNT1_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT1_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT1_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT1_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT1_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT1_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT1_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT1_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR1A - Output Compare Register
                                 .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
                                 .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
                                 .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
                                 .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
                                 .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
                                 .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
                                 .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
                                 .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
                                 
                                 ; OCR1B - Output Compare Register
                                 .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
                                 .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
                                 .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
                                 .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
                                 .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
                                 .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
                                 .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
                                 .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
                                 
                                 ; OCR1C - Output compare register
                                 .equ	OCR1C0	= 0	; 
                                 .equ	OCR1C1	= 1	; 
                                 .equ	OCR1C2	= 2	; 
                                 .equ	OCR1C3	= 3	; 
                                 .equ	OCR1C4	= 4	; 
                                 .equ	OCR1C5	= 5	; 
                                 .equ	OCR1C6	= 6	; 
                                 .equ	OCR1C7	= 7	; 
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 5	; OCIE1A: Timer/Counter1 Output Compare B Interrupt Enable
                                 .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 5	; Timer/Counter1 Output Compare Flag 1B
                                 .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
                                 
                                 ; GTCCR - Timer counter control register
                                 .equ	PSR1	= 1	; Prescaler Reset Timer/Counter1
                                 .equ	FOC1A	= 2	; Force Output Compare 1A
                                 .equ	FOC1B	= 3	; Force Output Compare Match 1B
                                 .equ	COM1B0	= 4	; Comparator B Output Mode
                                 .equ	COM1B1	= 5	; Comparator B Output Mode
                                 .equ	PWM1B	= 6	; Pulse Width Modulator B Enable
                                 
                                 ; DTPS - Dead time prescaler register
                                 .equ	DTPS0	= 0	; 
                                 .equ	DTPS1	= 1	; 
                                 
                                 ; DT1A - Dead time value register
                                 .equ	DTVL0	= 0	; 
                                 .equ	DTVL1	= 1	; 
                                 .equ	DTVL2	= 2	; 
                                 .equ	DTVL3	= 3	; 
                                 .equ	DTVH0	= 4	; 
                                 .equ	DTVH1	= 5	; 
                                 .equ	DTVH2	= 6	; 
                                 .equ	DTVH3	= 7	; 
                                 
                                 ; DT1B - Dead time value B
                                 ;.equ	DTVL0	= 0	; 
                                 ;.equ	DTVL1	= 1	; 
                                 ;.equ	DTVL2	= 2	; 
                                 ;.equ	DTVL3	= 3	; 
                                 ;.equ	DTVH0	= 4	; 
                                 ;.equ	DTVH1	= 5	; 
                                 ;.equ	DTVH2	= 6	; 
                                 ;.equ	DTVH3	= 7	; 
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	RFLB	= 3	; Read fuse and lock bits
                                 .equ	CTPB	= 4	; Clear temporary page buffer
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	PUD	= 6	; Pull-up Disable
                                 
                                 ; MCUSR - MCU Status register
                                 .equ	PORF	= 0	; Power-On Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSI	= 1	; Power Reduction USI
                                 .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 
                                 ; OSCCAL - Oscillator Calibration Register
                                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                                 .equ	CAL7	= 7	; Oscillatro Calibration Value Bit 7
                                 
                                 ; PLLCSR - PLL Control and status register
                                 .equ	PLOCK	= 0	; PLL Lock detector
                                 .equ	PLLE	= 1	; PLL Enable
                                 .equ	PCKE	= 2	; PCK Enable
                                 .equ	LSM	= 7	; Low speed mode
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; DWDR - debugWire data register
                                 .equ	DWDR0	= 0	; 
                                 .equ	DWDR1	= 1	; 
                                 .equ	DWDR2	= 2	; 
                                 .equ	DWDR3	= 3	; 
                                 .equ	DWDR4	= 4	; 
                                 .equ	DWDR5	= 5	; 
                                 .equ	DWDR6	= 6	; 
                                 .equ	DWDR7	= 7	; 
                                 
                                 ; GPIOR2 - General Purpose IO register 2
                                 .equ	GPIOR20	= 0	; 
                                 .equ	GPIOR21	= 1	; 
                                 .equ	GPIOR22	= 2	; 
                                 .equ	GPIOR23	= 3	; 
                                 .equ	GPIOR24	= 4	; 
                                 .equ	GPIOR25	= 5	; 
                                 .equ	GPIOR26	= 6	; 
                                 .equ	GPIOR27	= 7	; 
                                 
                                 ; GPIOR1 - General Purpose register 1
                                 .equ	GPIOR10	= 0	; 
                                 .equ	GPIOR11	= 1	; 
                                 .equ	GPIOR12	= 2	; 
                                 .equ	GPIOR13	= 3	; 
                                 .equ	GPIOR14	= 4	; 
                                 .equ	GPIOR15	= 5	; 
                                 .equ	GPIOR16	= 6	; 
                                 .equ	GPIOR17	= 7	; 
                                 
                                 ; GPIOR0 - General purpose register 0
                                 .equ	GPIOR00	= 0	; 
                                 .equ	GPIOR01	= 1	; 
                                 .equ	GPIOR02	= 2	; 
                                 .equ	GPIOR03	= 3	; 
                                 .equ	GPIOR04	= 4	; 
                                 .equ	GPIOR05	= 5	; 
                                 .equ	GPIOR06	= 6	; 
                                 .equ	GPIOR07	= 7	; 
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock source
                                 .equ	CKSEL1	= 1	; Select Clock source
                                 .equ	CKSEL2	= 2	; Select Clock source
                                 .equ	CKSEL3	= 3	; Select Clock source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock Output Enable
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
                                 .equ	WDTON	= 4	; Watchdog Timer always on
                                 .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
                                 .equ	DWEN	= 6	; DebugWIRE Enable
                                 .equ	RSTDISBL	= 7	; External Reset disable
                                 
                                 ; EXTENDED fuse bits
                                 .equ	SELFPRGEN	= 0	; Self-Programming Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0060
                                 .equ	SRAM_SIZE	= 512
                                 .equ	RAMEND	= 0x025f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x01ff
                                 .equ	EEPROMEND	= 0x01ff
                                 .equ	EEADRBITS	= 9
                                 #pragma AVRPART MEMORY PROG_FLASH 8192
                                 #pragma AVRPART MEMORY EEPROM 512
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 512
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x0
                                 .equ	NRWW_STOP_ADDR	= 0xfff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x0
                                 .equ	PAGESIZE	= 32
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                                 .equ	PCI0addr	= 0x0002	; Pin change Interrupt Request 0
                                 .equ	OC1Aaddr	= 0x0003	; Timer/Counter1 Compare Match 1A
                                 .equ	OVF1addr	= 0x0004	; Timer/Counter1 Overflow
                                 .equ	OVF0addr	= 0x0005	; Timer/Counter0 Overflow
                                 .equ	ERDYaddr	= 0x0006	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0007	; Analog comparator
                                 .equ	ADCCaddr	= 0x0008	; ADC Conversion ready
                                 .equ	OC1Baddr	= 0x0009	; Timer/Counter1 Compare Match B
                                 .equ	OC0Aaddr	= 0x000a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x000b	; Timer/Counter0 Compare Match B
                                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out
                                 .equ	USI_STARTaddr	= 0x000d	; USI START
                                 .equ	USI_OVFaddr	= 0x000e	; USI Overflow
                                 
                                 .equ	INT_VECTORS_SIZE	= 15	; size in words
                                 
                                 #endif  /* _TN85DEF_INC_ */
                                 
                                 
                                 ; based on UDCBuckHW.asm
                                 ;
                                 ; Author : Pavel
                                 ;
                                 
                                 ; Start to charge when voltage is 4v/cell or less
                                 
                                 #define DEBUG
                                 
                                 #define	MOVINGAVERAGE ; comment it if not needed
                                 .EQU	MOVINGAVERAGE_N = 5 ; can be 3, 5 or 7.
                                 
                                 ;Samsung INR18650-29E 2900mAh E6 - 8.25A
                                 .EQU	CELLS					= 6		; How many cells in series to charge
                                 .EQU	CELL_CAPACITANCE		= 290 * 3 ; 2900mAh 3 parallell
                                 .EQU	TRIGGER_CHARGE_VOLTAGE	= CELLS * 4 * 100 ; 4v/cell (mV*10)
                                 .EQU	CHARGE_CURRENT			= 200	; 2A - limited by power unit (when working together with amplifier)
                                 .EQU	CHARGE_CUTOFF			= 17		; 170mA (0.02C cutoff)
                                 
                                 .include "tn85def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny85.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn85def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny85
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny85
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN85DEF_INC_
                                 #endif  /* _TN85DEF_INC_ */
                                 
                                 
                                 ; Pins assignment
                                 .EQU	PIN_LED		= PB0	; WS2812B pin
                                 .EQU	PIN_PWM		= PB1	; PWM to Buck mosfet driver
                                 ;.EQU	PIN_SCL		= PB2	; I2C_SCL
                                 .EQU	PIN_Isense	= PB3	; Current measurement (analog signal)
                                 .EQU	PIN_Vsense	= PB4	; Voltage measurement (analog signal)
                                 
                                 
                                 ; variables assignment
                                 .def	z0			=	r0
                                 .def	z1			=	r1
                                 .def	r_sreg		=	r2	; Store SREG register in interrupts
                                 .def	tmp			=	r16
                                 .def	tmp1		=	r17
                                 .def	tmp2		=	r3
                                 .def	tmp3		=	r4
                                 .def	tmp4		=	r5
                                 .def	itmp		=	r18	; variables to use in interrupts
                                 .def	itmp1		=	r19	; variables to use in interrupts
                                 .def	itmp2		=	r6	; variables to use in interrupts
                                 .def	itmp3		=	r7	; variables to use in interrupts
                                 .def	tmpL1		=	r8	; temp register for 16 bit calculations
                                 .def	tmpH1		=	r9	; temp register for 16 bit calculations
                                 .def	tmpL2		=	r10	; temp register for 16 bit calculations
                                 .def	tmpH2		=	r11	; temp register for 16 bit calculations
                                 .def	ADC_counter	=	r20	; Flags for ADC. Refer to ADC.inc for details
                                 .def	Charge_flags=	r21	; Flags for Charging 
                                 	; bit 7 - Regulate PWM - bit sets every 1ms indicating that we can compare voltages and adjust PWM.
                                 	; bit 6 - If not charging, then check for trigger voltage to start charge. If charging, then charge till full
                                 	.EQU	Charge_flag_regulatePWM = 7
                                 	.EQU	Charge_flag_Charging	= 6 
                                 ; YH:YL 
                                 ; ZH:ZL for general use in main loop
                                 .DSEG
                                 .ORG SRAM_START
000060                           Voltage_Measured:			.BYTE 2 ; (mV*10)
000062                           Current_Measured:			.BYTE 2 ; (mA*10)
000064                           ADC_Current_zero_RAW:		.BYTE 2	; ADC value when no load (0.0A)
                                 #ifdef MOVINGAVERAGE
000066                           M_AVERAGE_voltage_COUNTER:	.BYTE 1	 ; Counter in the table
000067                           M_AVERAGE_voltage_TABLE:	.BYTE MOVINGAVERAGE_N * 2 ; Table for running moving average algorithm (max 14 bytes).
000071                           M_AVERAGE_current_COUNTER:	.BYTE 1	 ; Counter in the table
000072                           M_AVERAGE_current_TABLE:	.BYTE MOVINGAVERAGE_N * 2 ; Table for running moving average algorithm (max 14 bytes).
                                 #endif
                                 ; RGB bytes
00007c                           byteG:						.BYTE 1
00007d                           byteR:						.BYTE 1
00007e                           byteB:						.BYTE 1
                                 
                                 .CSEG
                                 .ORG 0
                                 
                                 	; Interrupt vectors
000000 c1a3                      	rjmp RESET ; Reset Handler
000001 9518                      	reti	;rjmp EXT_INT0 ; IRQ0 Handler
000002 9518                      	reti	;PCINT0 External Interrupt Request 1
000003 9518                      	reti	;TIMER1 COMPA Timer/Counter1 Compare Match A
000004 9518                      	reti	;TIMER1 OVF Timer/Counter1 Overflow
000005 9518                      	reti	;TIMER0 OVF Timer/Counter0 Overflow
000006 9518                      	reti	;EE_RDY EEPROM Ready
000007 9518                      	reti	;ANA_COMP Analog Comparator
000008 9518                      	reti	;ADC_INT ;ADC Conversion Complete
000009 9518                      	reti	;TIMER1 COMPB Timer/Counter1 Compare Match B
00000a c0b6                      	rjmp TMR0_COMPA ; Timer/Counter0 Compare Match A
00000b 9518                      	reti	;TIMER0 COMPB Timer/Counter0 Compare Match B
00000c 9518                      	reti	;WDT
00000d 9518                      	reti	;rjmp USI_start	; USI start
00000e 9518                      	reti	;rjmp USI_ovf	; USI Overflow
                                 
                                 	
                                 .include "PWM.inc"
                                 
                                 ; 250 Khz
                                 init_PWM:
00000f 98c1                      	cbi PORTB, PIN_PWM		; after reset it will be LOW,( but still, let's force it to LOW.
000010 9ab9                      	sbi DDRB, PIN_PWM		; output
000011 bc0f                      	out TCNT1, z0
000012 bc0e                      	out OCR1A, z0			; no PWM
000013 775f                      	cbr Charge_flags, 1<<Charge_flag_regulatePWM
000014 e601                      	ldi tmp, (0<<CS13) | (0<<CS12) | (0<<CS11) | (1<<CS10) | (1<<PWM1A) | (1<<COM1A1) | (0<<COM1A0)	; prescaller 1; fast PWM on OC1A
000015 bf00                      	out TCCR1, tmp	
                                 	; Enable 64mhz
000016 e002                      	ldi tmp, (1<<PLLE)
000017 bd07                      	out PLLCSR, tmp
                                 	; wait until clock stabilize (about 100us)
                                 waitPLL:
000018 b507                      	in tmp, PLLCSR
000019 ff00                      	sbrs tmp, PLOCK
00001a cffd                      	rjmp waitPLL
00001b e006                      	ldi tmp, (1<<PCKE) | (1<<PLLE)
00001c bd07                      	out PLLCSR, tmp
00001d 9508                      	ret
                                 
                                 ; Reduce PWM immediately. this way we will protect our batteries
                                 reduce_PWM:
00001e b50e                      	in tmp, OCR1A	; read current PWM
00001f 3000                      	cpi tmp, 0
000020 f011                      	breq reduce_PWM_exit
000021 950a                      	dec tmp
000022 bd0e                      	out OCR1A, tmp
                                 reduce_PWM_exit:
000023 9508                      	ret
                                 
                                 	; The routine checks measured voltage and compare it to the desired voltage (setVolt_tmp)
                                 increase_PWM:
                                 	; check flag PWM_flag_regulatePWM
000024 ff57                      	sbrs Charge_flags, Charge_flag_regulatePWM
000025 c006                      	rjmp increase_PWM_exit
000026 775f                      	cbr Charge_flags, (1<<Charge_flag_regulatePWM)	; clear flag
000027 b51e                      	in tmp1, OCR1A	; read current PWM
                                 	; we increase PWM by 1.
000028 3f1f                      	cpi tmp1, 255
000029 f011                      	breq increase_PWM_exit
00002a 9513                      	inc tmp1
00002b bd1e                      	out OCR1A, tmp1
                                 increase_PWM_exit:
00002c 9508                      	ret
                                 .include "ADC.inc"
                                 
                                 ; We measure first 8 samples of V.
                                 ; Then measure 1 sample of I.
                                 ; So, I will be measured 8 times slower than V.
                                 ;
                                 ; All ADC raw data should be multiplied by 2. It is ment to use in averaging (to get 1 bit more precision by oversampling).
                                 ; Then in convertion formula this will be taked care.
                                 ; ADC_counter:
                                 ;  0 - skip ADC reading
                                 ;  1-8 - Read Voltage
                                 ;  8 - after reading, change ADC channel to I
                                 ;  9 - skip ADC reading
                                 ;  10 - Read Current
                                 ;  10 - after reading, change ADC channel to V and reset counter
                                 
                                 .EQU 	VSENSE_ADC = (0<<MUX3) | (0<<MUX2) | (1<<MUX1) | (0<<MUX0) ; ADC2 (PB4) 
                                 .EQU 	ISENSE_ADC = (0<<MUX3) | (0<<MUX2) | (1<<MUX1) | (1<<MUX0) ; ADC3 (PB3)
                                 ;.EQU 	INTTEMP_ADC = (1<<MUX3) | (1<<MUX2) | (1<<MUX1) | (1<<MUX0) ; ADC4 (Internal temperature sensor)
                                 
                                 .EQU	VOLT_DIV_CONST		= 23		; To get this number use formula (for 28.50v max): 
                                 										; VREF=5v 
                                 										; 4095/(Vmax*10)*8, where Vmax=(R1+R2)*VREF/R2
                                 										; and resistor values is from divider (47K/10K)
                                 										; Vmax=(47+10)*VREF/10=28.5
                                 										; 4095*2/(28.5*100)*8=22.99
                                 										; Remember, that ADC raw value is multiplied by 2! So, in the next formula we divide it by 2.
                                 										; And then voltage will be calculated as ADC * 64/2 / VOLT_DIV_CONST
                                 
                                 .EQU	CURRENT_DIV_CONST	= 48		; To get this number use formula (for 185mV/A sensor): 
                                 										; VREF=5000mV 
                                 										; MULCOEFF=VREF/10*(1000/4)/185/1023
                                 										; 1/MULCOEFF*32=48
                                 										; Remember, that ADC raw value is multiplied by 2! So, in the next formula we divide it by 2.
                                 										; And then current (in mA*10) will be calculated as (ADC-ADC_Current_zero_RAW)*(4/2)*32/CURRENT_DIV_CONST
                                 										
                                 ADC_Read:
00002d b034                      	in tmp2, ADCL
00002e b045                      	in tmp3, ADCH
                                 	; multiply by 2
00002f 0c33                      	add tmp2, tmp2
000030 1c44                      	adc tmp3, tmp3
000031 3048                      	cpi ADC_counter, 8	; check counter
000032 f419                      	brne ADC_skp_change_1
                                 	; Change channel to I
000033 e003                      	ldi tmp, ISENSE_ADC
000034 b907                      	out ADMUX, tmp
000035 c004                      	rjmp ADC_skp_change_2
                                 ADC_skp_change_1:
000036 304a                      	cpi ADC_counter, 10	; check counter
000037 f411                      	brne ADC_skp_change_2
                                 	; Change channel to V
000038 e002                      	ldi tmp, VSENSE_ADC
000039 b907                      	out ADMUX, tmp
                                 ADC_skp_change_2:
                                 	; start new ADC reading
00003a 9a36                      	sbi ADCSRA, ADSC
                                 	; continue to analyze counter
00003b 3040                      	cpi ADC_counter, 0	; skip reading
00003c f031                      	breq adc_exit
00003d 3049                      	cpi ADC_counter, 9	; 1-8
00003e f030                      	brlo ADC_read_Volt
00003f 3049                      	cpi ADC_counter, 9 ; skip reading
000040 f011                      	breq adc_exit
000041 304a                      	cpi ADC_counter, 10 
000042 f021                      	breq ADC_read_Current
                                 
                                 adc_exit:
000043 9543                      	inc ADC_counter	; increment counter
000044 9508                      	ret
                                 ADC_read_Volt:
000045 d0e3                      	rcall Convert_VoltageADC_to_Volt
000046 cffc                      	rjmp adc_exit
                                 ADC_read_Current:
000047 d0f4                      	rcall Convert_CurrentADC_to_Current
                                 	; also reset counter
000048 ef4f                      	ldi ADC_counter, 255	; Before exit counter will became 0.
000049 cff9                      	rjmp adc_exit
                                 
                                 
                                 init_ADC:
00004a 94f8                      	cli	; just in case
                                 	; Initialize remaining pins
                                 	#ifndef DEBUG	; disable digital logic only in "prodution"
                                 	#endif
00004b 98bc                      	cbi DDRB, PIN_Vsense	; input
00004c 98bb                      	cbi DDRB, PIN_Isense	; input
                                 	; Initialize ADC variables
00004d 2744                      	clr ADC_counter
                                 	; set 125khz clock for ADC (8mhz/64)m interrupt
00004e e806                      	ldi tmp, (1<<ADPS2) | (1<<ADPS1) | (0<<ADPS0) | (0<<ADIE) | (1<<ADEN)	; no interrupts
00004f b906                      	out ADCSRA, tmp
                                 	; configure channel 
                                 	; voltage reference by default is VCC
000050 e003                      	ldi tmp, ISENSE_ADC
000051 b907                      	out ADMUX, tmp
                                 	#ifdef MOVINGAVERAGE
                                 		; fill M_average array for I
000052 e7e1                      		ldi ZL, LOW(M_AVERAGE_current_COUNTER)
000053 e0f0                      		ldi ZH, HIGH(M_AVERAGE_current_COUNTER)
000054 d00b                      		rcall init_ADC_array
                                 	#else
                                 	#endif
                                 	; store last value to get reference for Current measurement (0.0A)
000055 9230 0064                 	sts ADC_Current_zero_RAW, tmp2
000057 9240 0065                 	sts ADC_Current_zero_RAW+1, tmp3
                                 
000059 e002                      	ldi tmp, VSENSE_ADC
00005a b907                      	out ADMUX, tmp
                                 	#ifdef MOVINGAVERAGE
                                 		; fill M_average array for V
00005b e6e6                      		ldi ZL, LOW(M_AVERAGE_voltage_COUNTER)
00005c e0f0                      		ldi ZH, HIGH(M_AVERAGE_voltage_COUNTER)
00005d d002                      		rcall init_ADC_array
                                 		; now V channel is selected
                                 	#endif
                                 	; clear ADC interrupt flag
00005e 9a34                      	sbi ADCSRA, ADIF
                                 	; no sense to store voltage now
                                 	;sts ADC_Voltage_RAW, itmp2
                                 	;sts ADC_Voltage_RAW+1, itmp3
00005f 9508                      	ret
                                 
                                 #ifdef MOVINGAVERAGE
                                 init_ADC_array:
000060 e00a                      	ldi tmp, MOVINGAVERAGE_N * 2
                                 init_ADC_loop:
000061 930f                      	push tmp
000062 93ef                      	push ZL
000063 93ff                      	push ZH
                                 	; start first conversion
000064 9a36                      	sbi ADCSRA, ADSC
                                 	; wait for result
                                 waitforADC:
000065 9936                      	sbic ADCSRA, ADSC
000066 cffe                      	rjmp waitforADC
                                 	; read ADC
000067 b034                      	in tmp2, ADCL
000068 b045                      	in tmp3, ADCH
                                 	; multiply by 2
000069 0c33                      	add tmp2, tmp2
00006a 1c44                      	adc tmp3, tmp3
00006b d00c                      	rcall moving_average	; fill array
00006c 91ff                      	pop ZH
00006d 91ef                      	pop ZL
00006e 910f                      	pop tmp
00006f 950a                      	dec tmp
000070 f781                      	brne init_ADC_loop
000071 9508                      	ret
                                 #endif
                                 .include "MovAverage.inc"
                                 
                                 
                                 ; while Mov Average init interrupts should be disabled
                                 init_Moving_Average:
000072 94f8                      	cli	; just in case
000073 9200 0066                 	sts M_AVERAGE_voltage_COUNTER, z0
000075 9200 0071                 	sts M_AVERAGE_current_COUNTER, z0
000077 9508                      	ret
                                 
                                 
                                 ; smooth data via moving average algorithm
                                 ; store/read 11 bit value to the Moving Average array
                                 ; value is in tmp2:tmp3 
                                 ; Z points to the array of data (Counter and averaging data)
                                 moving_average:
                                 	; we will run average within MOVINGAVERAGE_N values.
                                 	; pointer for moving average table
000078 93ef                      	push ZL	; store for future use
000079 93ff                      	push ZH	; store for future use
00007a 9101                      	ld tmp, Z+
00007b 2f10                      	mov tmp1, tmp
00007c 0f11                      	lsl tmp1	; multiply by 2 because we operate with 16 bit values
00007d 0fe1                      	add ZL, tmp1
00007e 1df0                      	adc ZH, z0
                                 	; store current value in the table
00007f 9231                      	st Z+, tmp2
000080 8240                      	st Z, tmp3
                                 	; update counter
000081 9503                      	inc tmp
000082 3005                      	cpi tmp, MOVINGAVERAGE_N
000083 f409                      	brne mov_avrg_skp
000084 2700                      	clr tmp
                                 mov_avrg_skp:
000085 91ff                      	pop ZH
000086 91ef                      	pop ZL
000087 9301                      	st Z+, tmp	; Store counter
                                 	; sum all values in the table
                                 	; Z points to the first element in the table
000088 e005                      	ldi tmp, MOVINGAVERAGE_N
000089 2488                      	clr tmpL1
00008a 2499                      	clr tmpH1
                                 mov_avrg_loop:
00008b 9031                      	ld tmp2, Z+
00008c 9041                      	ld tmp3, Z+
00008d 0c83                      	add tmpL1, tmp2
00008e 1c94                      	adc tmpH1, tmp3
00008f 950a                      	dec tmp
000090 f7d1                      	brne mov_avrg_loop
                                 	; divide result by MOVINGAVERAGE_N
000091 e005                      	ldi tmp, MOVINGAVERAGE_N
000092 2ea0                      	mov tmpL2, tmp
000093 24bb                      	clr tmpH2
000094 d003                      	rcall div16u
                                 	; new result store back to tmp2:tmp3
000095 2c38                      	mov tmp2, tmpL1
000096 2c49                      	mov tmp3, tmpH1
000097 9508                      	ret
                                 
                                 #endif	
                                 .include "math.inc"
                                 
                                 ;*
                                 ;* "div16u" - 16/16 Bit Unsigned Division
                                 ;*
                                 ;* This subroutine divides the two 16-bit numbers 
                                 ;* "tmpH1:tmpL1" (dividend) and "tmpH2:tmpL2" (divisor). 
                                 ;* The result is placed in "tmpH1:tmpL1" and the remainder in
                                 ;* "tmp3:tmp2".
                                 ;*  
                                 ;* Number of words	:19+reminder routine (7)
                                 ;* Number of cycles	:235/251 (Min/Max)
                                 ;* Low registers used	:6 (tmpL1,tmpH1,tmpL2,tmpH2,tmp2,tmp3)
                                 ;* High registers used  :1 (tmp)
                                 ;*
                                 ;***************************************************************************
                                 ; about 25us at 9.6mhz
000098 2433                      div16u:	clr	tmp2	;clear remainder Low byte
000099 1844                      	sub	tmp3,tmp3;clear remainder High byte and carry
00009a e101                      	ldi	tmp,17	;init loop counter
00009b 1c88                      d16u_1:	rol	tmpL1		;shift left dividend
00009c 1c99                      	rol	tmpH1
00009d 950a                      	dec	tmp		;decrement counter
00009e f441                      	brne	d16u_2		;if done
                                 	; take care of reminder (we want to have coeff as precise as possible)
                                 	;divide divisor by 2
00009f 94b6                      	lsr tmpH2
0000a0 94a7                      	ror tmpL2
                                 	; compare reminder to half of divisor
0000a1 143a                      	cp  tmp2, tmpL2 
0000a2 044b                      	cpc	tmp3, tmpH2
0000a3 f010                      	brlo d16u_exit
                                 	; increment result
0000a4 0c81                      	add tmpL1, z1
0000a5 1c90                      	adc tmpH1, z0
                                 d16u_exit:
0000a6 9508                      	ret			;    return
0000a7 1c33                      d16u_2:	rol	tmp2	;shift dividend into remainder
0000a8 1c44                      	rol	tmp3
0000a9 183a                      	sub	tmp2,tmpL2	;remainder = remainder - divisor
0000aa 084b                      	sbc	tmp3,tmpH2	;
0000ab f420                      	brcc	d16u_3		;if result negative
0000ac 0c3a                      	add	tmp2,tmpL2	;    restore remainder
0000ad 1c4b                      	adc	tmp3,tmpH2
0000ae 9488                      	clc			;    clear carry to be shifted into result
0000af cfeb                      	rjmp	d16u_1		;else
0000b0 9408                      d16u_3:	sec			;    set carry to be shifted into result
                                 .include "scheduler.inc"
0000b1 cfe9                      
                                 ; At 8Mhz divider is 1/64 and overflow value is 125 (OCR0A).
                                 init_Scheduler:
                                 	; Halt the timer
0000b2 e801                      	ldi tmp, (1<<TSM) | (1<<PSR0)
0000b3 bd0c                      	out GTCCR, tmp		; we don't care about timer1 as GTCCR is not used there
                                 	; Configure timer in CTC mode and prescaller
0000b4 e002                      	ldi tmp, (1<<WGM01) | (0<<WGM00)
0000b5 bd0a                      	out TCCR0A, tmp
0000b6 e003                      	ldi tmp, (0<<WGM02) | (0<<CS02) | (1<<CS01) | (1<<CS00)
0000b7 bf03                      	out TCCR0B, tmp
0000b8 be02                      	out TCNT0, z0
                                 	; Set top value to match 1ms.
0000b9 e70d                      	ldi tmp, 125
0000ba bd09                      	out OCR0A, tmp
                                 	; Enable interrupt 
0000bb e100                      	ldi tmp, (1<<OCIE0A)
0000bc bf09                      	out TIMSK, tmp		; we don't care about timer1 interrupts as we don't use them. 
0000bd 9508                      	ret
                                 	
                                 	
                                 Scheduler_start:
                                 	; start timer when everything else configured and ready
0000be e000                      	ldi tmp, (0<<TSM)
0000bf bd0c                      	out GTCCR, tmp		; we don't care about timer1 as GTCCR is not used there
0000c0 9508                      	ret
                                 	
                                 ; interrupt for timer0 counting (every 1ms)
                                 TMR0_COMPA:
0000c1 b62f                      	in r_sreg, SREG
0000c2 6850                      	sbr Charge_flags, (1<<Charge_flag_regulatePWM)	; We adjust PWM every 1ms.
0000c3 be2f                      	out SREG, r_sreg
0000c4 9518                      	reti
                                 .include "ws2812b.inc"
                                 
                                 ; https://cpldcpu.wordpress.com/2014/01/14/light_ws2812-library-v2-0-part-i-understanding-the-ws2812/
                                 ;
                                 
                                 ws2812_init:
                                 	#ifdef DEBUG
                                 		; enable output for power LED from I2c connector
0000c5 9aba                      		sbi DDRB, PB2
0000c6 9ac2                      		sbi PORTB, PB2
                                 	#endif
                                 	; initialize pin
0000c7 9ab8                      	sbi DDRB, PIN_LED
0000c8 98c0                      	cbi PORTB, PIN_LED
                                 	; clear SRAM location
0000c9 9508                      	ret
                                 
                                 
                                 LED_off:
0000ca 9200 007d                 	sts byteR, z0
0000cc 9200 007c                 	sts byteG, z0
0000ce 9200 007e                 	sts byteB, z0
0000d0 c000                      	rjmp wsLED
                                 
                                 
                                 ; about 30us per LED
                                 wsLED:
0000d1 e003                      	ldi tmp, 3 ; bytes to send
0000d2 e011                      	ldi tmp1, 1<<PIN_LED
0000d3 2e41                      	mov tmp3, tmp1	; pin to trigger
0000d4 e017                      	ldi tmp1, 7
0000d5 e7ec                      	ldi ZL, LOW(byteG)
0000d6 e0f0                      	ldi ZH, HIGH(byteG)
0000d7 9031                      	ld tmp2, Z+
0000d8 94f8                      	cli
                                 wsl01:
0000d9 0000                      	nop
                                 wsl02:
0000da 98c0                      	cbi PORTB, PIN_LED
                                 wsl03:
0000db 0c33                      	lsl tmp2
0000dc ba46                      	out PINB, tmp3
0000dd f008                      	brcs wsl04
0000de ba46                      	out PINB, tmp3
                                 wsl04:
0000df 951a                      	dec tmp1
0000e0 f7c1                      	brne wsl01
0000e1 0c33                      	lsl tmp2
0000e2 98c0                      	cbi PORTB, PIN_LED
0000e3 e017                      	ldi tmp1, 7
0000e4 ba46                      	out PINB, tmp3
0000e5 f420                      	brcc wsl05
0000e6 9031                      	ld tmp2, Z+
0000e7 950a                      	dec tmp
0000e8 f789                      	brne wsl02
0000e9 c004                      	rjmp wsl06
                                 wsl05:	
0000ea ba46                      	out PINB, tmp3
0000eb 9031                      	ld 	tmp2, Z+
0000ec 950a                      	dec tmp
0000ed f769                      	brne wsl03
                                 wsl06:
0000ee 98c0                      	cbi PORTB, PIN_LED
0000ef 9478                      	sei
0000f0 9508                      	ret
                                 	
                                 	
                                 ; preset colors for debug
                                 #ifdef DEBUG	
                                 	.EQU	color_intense = 150
                                 
                                 	debug_red:
0000f1 e906                      		ldi tmp, color_intense
0000f2 9300 007d                 		sts byteR, tmp
0000f4 9200 007c                 		sts byteG, z0
0000f6 9200 007e                 		sts byteB, z0
0000f8 cfd8                      		rjmp wsLED
                                 
                                 	debug_green:
0000f9 e906                      		ldi tmp, color_intense
0000fa 9200 007d                 		sts byteR, z0
0000fc 9300 007c                 		sts byteG, tmp
0000fe 9200 007e                 		sts byteB, z0
000100 cfd0                      		rjmp wsLED
                                 
                                 	debug_blue:
000101 e906                      		ldi tmp, color_intense
000102 9200 007d                 		sts byteR, z0
000104 9200 007c                 		sts byteG, z0
000106 9300 007e                 		sts byteB, tmp
000108 cfc8                      		rjmp wsLED
                                 
                                 	debug_white:
000109 e906                      		ldi tmp, color_intense
00010a 9300 007d                 		sts byteR, tmp
00010c 9300 007c                 		sts byteG, tmp
00010e 9300 007e                 		sts byteB, tmp
000110 cfc0                      		rjmp wsLED
                                 
                                 	debug_violet:
000111 e906                      		ldi tmp, color_intense
000112 9300 007d                 		sts byteR, tmp
000114 9200 007c                 		sts byteG, z0
000116 9300 007e                 		sts byteB, tmp
000118 cfb8                      		rjmp wsLED
                                 
                                 	debug_yellow:
000119 e906                      		ldi tmp, color_intense
00011a 9300 007d                 		sts byteR, tmp
00011c 9300 007c                 		sts byteG, tmp
00011e 9200 007e                 		sts byteB, z0
000120 cfb0                      		rjmp wsLED
                                 
                                 	debug_cyan:
000121 e906                      		ldi tmp, color_intense
000122 9200 007d                 		sts byteR, z0
000124 9300 007c                 		sts byteG, tmp
000126 9300 007e                 		sts byteB, tmp
000128 cfa8                      		rjmp wsLED
                                 #endif
                                 ;.include "EEPROM.inc"
                                 .include "main.inc"
                                 
                                 ; Remember, that raw ADC is multiplied by 2!
                                 Convert_VoltageADC_to_Volt:
                                 	#ifdef MOVINGAVERAGE
000129 e6e6                      		ldi ZL, LOW(M_AVERAGE_voltage_COUNTER)
00012a e0f0                      		ldi ZH, HIGH(M_AVERAGE_voltage_COUNTER)
00012b df4c                      		rcall moving_average
                                 	#endif
                                 	; Value is ready for converting to Volts (actually mV*10 eg 1200 = 12.00V)
                                 	; The formula is: ADC * 64 / 2 / VOLT_DIV_CONST
00012c e005                      	ldi tmp, 5
                                 mult32:
00012d 0c33                      	lsl tmp2
00012e 1c44                      	rol tmp3
00012f 950a                      	dec tmp
000130 f7e1                      	brne mult32
                                 	; divide it by a constant
000131 2c83                      	mov tmpL1, tmp2
000132 2c94                      	mov tmpH1, tmp3
000133 e107                      	ldi tmp, VOLT_DIV_CONST
000134 2ea0                      	mov tmpL2, tmp
000135 24bb                      	clr tmpH2
000136 df61                      	rcall div16u	; result in tmpH1:tmpL1 (actually only low byte)
000137 9280 0060                 	sts Voltage_Measured, tmpL1
000139 9290 0061                 	sts Voltage_Measured+1, tmpH1
                                 convert_V_exit:
00013b 9508                      	ret
                                 
                                 ; Convert ADC RAW current to real current
                                 ; Remember, that raw ADC is multiplied by 2!
                                 Convert_CurrentADC_to_Current:
                                 	#ifdef MOVINGAVERAGE
00013c e7e1                      		ldi ZL, LOW(M_AVERAGE_current_COUNTER)
00013d e0f0                      		ldi ZH, HIGH(M_AVERAGE_current_COUNTER)
00013e df39                      		rcall moving_average
                                 	#endif
                                 	; Value is ready for converting to Current (actually mA*10 eg 550 = 5.5A)
                                 	; ADC_Current_zero_RAW - reference for 0.0A
                                 	; The formula is: (ADC-ADC_Current_zero_RAW)*(4/2)*32/CURRENT_DIV_CONST
00013f 9080 0064                 	lds tmpL1, ADC_Current_zero_RAW
000141 9090 0065                 	lds tmpH1, ADC_Current_zero_RAW+1
000143 1838                      	sub tmp2, tmpL1
000144 0849                      	sbc tmp3, tmpH1
000145 f410                      	brcc convert_C_notminus
000146 2433                      	clr tmp2	; if minus, then 0
000147 2444                      	clr tmp3	; if minus, then 0
                                 convert_C_notminus:
                                 	; Result should be lower than 1024, otherwise it will overflow
000148 e004                      	ldi tmp, high(1024)
000149 1430                      	cp tmp2, z0
00014a 0640                      	cpc tmp3, tmp
00014b f020                      	brlo convert_C_nooverflow
00014c ef0f                      	ldi tmp, low(1023)
00014d 2e30                      	mov tmp2, tmp
00014e e003                      	ldi tmp, high(1023)
00014f 2e40                      	mov tmp3, tmp
                                 convert_C_nooverflow:
000150 e006                      	ldi tmp, 6
                                 mult64:
000151 0c33                      	lsl tmp2
000152 1c44                      	rol tmp3
000153 950a                      	dec tmp
000154 f7e1                      	brne mult64
                                 	; divide it by a constant
000155 2c83                      	mov tmpL1, tmp2
000156 2c94                      	mov tmpH1, tmp3
000157 e300                      	ldi tmp, CURRENT_DIV_CONST
000158 2ea0                      	mov tmpL2, tmp
000159 24bb                      	clr tmpH2
00015a df3d                      	rcall div16u	; result in tmpH1:tmpL1
00015b 9280 0062                 	sts Current_Measured, tmpL1
00015d 9290 0063                 	sts Current_Measured+1, tmpH1
                                 convert_C_exit:
00015f 9508                      	ret
                                 
                                 ; charging process
                                 ; first safety checks
                                 ; then try to increase pwm
                                 DoCharge:
                                 	; Are we charging?
000160 fd56                      	sbrc Charge_flags, Charge_flag_Charging
000161 c00a                      	rjmp Charging
                                 	; should we start charge?
000162 9080 0060                 	lds tmpL1, Voltage_Measured
000164 9090 0061                 	lds tmpH1, Voltage_Measured+1
000166 e600                      	ldi tmp, LOW(TRIGGER_CHARGE_VOLTAGE)
000167 e019                      	ldi tmp1, HIGH(TRIGGER_CHARGE_VOLTAGE)
000168 1680                      	cp tmpL1, tmp
000169 0691                      	cpc tmpH1, tmp1
00016a f008                      	brlo Charging	; start charging
00016b c01f                      	rjmp DoCharge_exit
                                 
                                 Charging:
00016c 6450                      	sbr Charge_flags, 1<<Charge_flag_Charging ; start charging
                                 	; check that voltage not higher than CELLS * 4.2V * 100
00016d 9080 0060                 	lds tmpL1, Voltage_Measured
00016f 9090 0061                 	lds tmpH1, Voltage_Measured+1
000171 ed09                      	ldi tmp, LOW(CELLS * 420 + 1)
000172 e019                      	ldi tmp1, HIGH(CELLS * 420 + 1)
000173 1680                      	cp tmpL1, tmp
000174 0691                      	cpc tmpH1, tmp1
000175 f050                      	brlo ChargeVoltageSafe
                                 	; Maybe we need to finish charge?
                                 	; Check cutoff Current
000176 9080 0062                 	lds tmpL1, Current_Measured
000178 9090 0063                 	lds tmpH1, Current_Measured+1
00017a e101                      	ldi tmp, LOW(CHARGE_CUTOFF)
00017b e010                      	ldi tmp1, HIGH(CHARGE_CUTOFF)
00017c 1680                      	cp tmpL1, tmp
00017d 0691                      	cpc tmpH1, tmp1
00017e f068                      	brlo Charging_Competed
                                 	; we need continue to charge, but reduce PWM
00017f de9e                      	rcall reduce_PWM	; reduce PWM
                                 ChargeVoltageSafe:
                                 	; Check Current
000180 9080 0062                 	lds tmpL1, Current_Measured
000182 9090 0063                 	lds tmpH1, Current_Measured+1
000184 ec08                      	ldi tmp, LOW(CHARGE_CURRENT)
000185 e010                      	ldi tmp1, HIGH(CHARGE_CURRENT)
000186 1680                      	cp tmpL1, tmp
000187 0691                      	cpc tmpH1, tmp1
000188 f008                      	brlo ChargeCurrentSafe
000189 de94                      	rcall reduce_PWM	; reduce PWM
                                 ChargeCurrentSafe:
00018a de99                      	rcall increase_PWM	; 1 unit per 1ms
                                 DoCharge_exit:
00018b 9508                      	ret
                                 
                                 Charging_Competed:
                                 	; need to clear flag Charge_flag_Charging  when fully charged
00018c 7b5f                      	cbr Charge_flags, 1<<Charge_flag_Charging
00018d bc0e                      	out OCR1A, z0	; turn off PWM
00018e cffc                      	rjmp DoCharge_exit
                                 
                                 
                                 ; Indicate charging process
                                 Charging_Status_LED:
                                 	; if not charging, then show the battery status (green)
00018f ff56                      	sbrs Charge_flags, Charge_flag_Charging
000190 c001                      	rjmp LED_status_Green
                                 	; if charging - show charging state
                                 	; CC (control Current) - RED
                                 	; CV (control Voltage) - ORANGE
                                 	; CHARGE_CUTOFF * 2 - BLINK GREEN
                                 
000191 9508                      	ret
                                 LED_status_Green:
000192 e302                      	ldi tmp, 50
000193 9300 007d                 	sts byteR, tmp
000195 e906                      	ldi tmp, 150
000196 9300 007c                 	sts byteG, tmp
000198 9200 007e                 	sts byteB, z0
00019a cf36                      	rjmp wsLED
                                 
                                 LED_status_Orange:
00019b e604                      	ldi tmp, 100
00019c 9300 007d                 	sts byteR, tmp
00019e e302                      	ldi tmp, 50
00019f 9300 007c                 	sts byteG, tmp
0001a1 9200 007e                 	sts byteB, z0
0001a3 cf2d                      	rjmp wsLED
                                 
                                 RESET:
0001a4 94f8                      	cli
                                 
                                 
                                 	;initialize constants
0001a5 2400                      	clr z0
0001a6 2411                      	clr z1
0001a7 9413                      	inc z1
                                 
0001a8 df1c                      	rcall ws2812_init
                                 	
0001a9 2755                      	clr Charge_flags
                                 	
0001aa e800                      	ldi tmp, 1<<CLKPCE	
0001ab bd06                      	out CLKPR, tmp		; enable clock change
0001ac bc06                      	out CLKPR, z0		; prescaler 1
                                 
0001ad e002                      	ldi tmp, high(RAMEND) 
0001ae bf0e                      	out SPH,tmp				; Set Stack Pointer to top of RAM
0001af e50f                      	ldi tmp, low(RAMEND)
0001b0 bf0d                      	out SPL,tmp				; Set Stack Pointer to top of RAM
                                 
0001b1 de5d                      	rcall init_PWM	; Initialize FET controlling with PWM
                                 	#ifdef MOVINGAVERAGE
0001b2 debf                      		rcall init_Moving_Average
                                 	#endif
0001b3 de96                      	rcall init_ADC			; Initialize V and I measuring
0001b4 defd                      	rcall init_Scheduler	; Initialize scheduler for smooth change to desired voltage
                                 
                                 
                                 	; this call should be the last before enabling interrupts and entering main loop
0001b5 df08                      	rcall Scheduler_start	
                                 
0001b6 9a36                      	sbi ADCSRA, ADSC
                                 	
0001b7 9478                      	sei
                                 	
                                 	#ifdef DEBUG
0001b8 dfd9                      		rcall LED_status_Green
                                 		;rcall sendColor
                                 		;rcall debug_off
                                 		;rcall debug_yellow
                                 	#endif
                                 	
                                 loop:
                                 	; wait for ADC complete
0001b9 9936                      	sbic ADCSRA, ADSC
0001ba cffe                      	rjmp loop
0001bb de71                      	rcall ADC_Read
                                 
0001bc dfa3                      	rcall DoCharge
0001bd cffb                      	rjmp loop


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny85" register use summary:
x  :   0 y  :   0 z  :   9 r0 :  25 r1 :   3 r2 :   2 r3 :  29 r4 :  30 
r5 :   0 r6 :   0 r7 :   0 r8 :  19 r9 :  19 r10:   7 r11:   7 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 108 r17:  20 r18:   0 r19:   0 r20:   9 
r21:   9 r22:   0 r23:   0 r24:   0 r25:   0 r26:   0 r27:   0 r28:   0 
r29:   0 r30:  10 r31:  10 
Registers used: 16 out of 35 (45.7%)

"ATtiny85" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   6 add   :   6 adiw  :   0 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   3 brcs  :   1 break :   0 breq  :   5 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   7 brlt  :   0 brmi  :   0 
brne  :  11 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 cbi   :   7 cbr   :   3 clc   :   1 
clh   :   0 cli   :   4 cln   :   0 clr   :  13 cls   :   0 clt   :   0 
clv   :   0 clz   :   0 com   :   0 cp    :   6 cpc   :   6 cpi   :   9 
cpse  :   0 dec   :   9 eor   :   0 icall :   0 ijmp  :   0 in    :   8 
inc   :   4 ld    :   6 ldd   :   0 ldi   :  62 lds   :  10 lpm   :   0 
lsl   :   5 lsr   :   1 mov   :  13 movw  :   0 neg   :   0 nop   :   1 
or    :   0 ori   :   0 out   :  29 pop   :   5 push  :   5 rcall :  22 
ret   :  17 reti  :  14 rjmp  :  27 rol   :   6 ror   :   1 sbc   :   2 
sbci  :   0 sbi   :   8 sbic  :   2 sbis  :   0 sbiw  :   0 sbr   :   2 
sbrc  :   1 sbrs  :   3 sec   :   1 seh   :   0 sei   :   2 sen   :   0 
ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :   3 std   :   0 sts   :  38 sub   :   3 subi  :   0 
swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 45 out of 105 (42.9%)

"ATtiny85" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00037c    892      0    892    8192  10.9%
[.dseg] 0x000060 0x00007f      0     31     31     512   6.1%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
